# Copyright 2020 Google
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from typing import cast, Iterable, Sequence, Tuple,  Dict, List, Optional
import copy
from collections import defaultdict

import numpy
import cirq
import util


EQ_TOLERANCE = 1.0E-12


class GivensTranspositionError(Exception):
    pass


class GivensMatrixError(Exception):
    pass


def givens_matrix_elements(a, b, which='left'):
    """Compute the matrix elements of the Givens rotation that zeroes out one
    of two row entries.

    If `which='left'` then returns a matrix G such that

        G * [a  b]^T= [0  r]^T

    otherwise, returns a matrix G such that

        G * [a  b]^T= [r  0]^T

    where r is a complex number.

    Args:
        a(complex or float): A complex number representing the upper row entry
        b(complex or float): A complex number representing the lower row entry
        which(string): Either 'left' or 'right', indicating whether to
            zero out the left element (first argument) or right element
            (second argument). Default is `left`.
    Returns:
        G(ndarray): A 2 x 2 numpy array representing the matrix G.
            The numbers in the first column of G are real.
    """
    # Handle case that a is zero
    if abs(a) < EQ_TOLERANCE:
        cosine = 1.
        sine = 0.
        phase = 1.
    # Handle case that b is zero and a is nonzero
    elif abs(b) < EQ_TOLERANCE:
        cosine = 0.
        sine = 1.
        phase = 1.
    # Handle case that a and b are both nonzero
    else:
        denominator = numpy.sqrt(abs(a)**2 + abs(b)**2)
        cosine = abs(b) / denominator
        sine = abs(a) / denominator
        sign_b = b / abs(b)
        sign_a = a / abs(a)
        phase = sign_a * sign_b.conjugate()
        # If phase is a real number, convert it to a float
        if numpy.isreal(phase):
            phase = numpy.real(phase)

    # Construct matrix and return
    if which == 'left':
        # We want to zero out a
        if (abs(numpy.imag(a)) < EQ_TOLERANCE and
                abs(numpy.imag(b)) < EQ_TOLERANCE):
            # a and b are real, so return a standard rotation matrix
            givens_rotation = numpy.array([[cosine, -phase * sine],
                                           [phase * sine, cosine]])
        else:
            givens_rotation = numpy.array([[cosine, -phase * sine],
                                           [sine, phase * cosine]])
    elif which == 'right':
        # We want to zero out b
        if (abs(numpy.imag(a)) < EQ_TOLERANCE and
                abs(numpy.imag(b)) < EQ_TOLERANCE):
            # a and b are real, so return a standard rotation matrix
            givens_rotation = numpy.array([[sine, phase * cosine],
                                           [-phase * cosine, sine]])
        else:
            givens_rotation = numpy.array([[sine, phase * cosine],
                                           [cosine, -phase * sine]])
    else:
        raise ValueError('"which" must be equal to "left" or "right".')
    return givens_rotation


def givens_rotate(operator, givens_rotation, i, j, which='row'):
    """Apply a Givens rotation to coordinates i and j of an operator."""
    if which == 'row':
        # Rotate rows i and j
        row_i = operator[i].copy()
        row_j = operator[j].copy()
        operator[i] = (givens_rotation[0, 0] * row_i +
                       givens_rotation[0, 1] * row_j)
        operator[j] = (givens_rotation[1, 0] * row_i +
                       givens_rotation[1, 1] * row_j)
    elif which == 'col':
        # Rotate columns i and j
        col_i = operator[:, i].copy()
        col_j = operator[:, j].copy()
        operator[:, i] = (givens_rotation[0, 0] * col_i +
                          givens_rotation[0, 1].conj() * col_j)
        operator[:, j] = (givens_rotation[1, 0] * col_i +
                          givens_rotation[1, 1].conj() * col_j)
    else:
        raise ValueError('"which" must be equal to "row" or "col".')


def optimal_givens_decomposition(qubits: Sequence[cirq.Qid],
                                 unitary: numpy.ndarray
                                ) -> Iterable[cirq.Operation]:
    r"""
    Implement a circuit that provides the unitary that is generated by
    single-particle fermion generators

    .. math::

        U(v) = exp(log(v)_{p,q}(a_{p}^{\dagger}a_{q} - a_{q}^{\dagger}a_{p})

    This can be used for implementing an exact single-body basis rotation

    Args:
        qubits: Sequence of qubits to apply the operations over.  The qubits
                should be ordered in linear physical order.
        unitary:
    """
    N = unitary.shape[0]
    right_rotations = []
    left_rotations = []
    for i in range(1, N):
        if i % 2 == 1:
            for j in range(0, i):
                # eliminate U[N - j, i - j] by mixing U[N - j, i - j],
                # U[N - j, i - j - 1] by right multiplication
                # of a givens rotation matrix in column [i - j, i - j + 1]
                gmat = givens_matrix_elements(unitary[N - j - 1, i - j - 1],
                                              unitary[N - j - 1, i - j - 1 + 1],
                                              which='left')
                right_rotations.append((gmat.T, (i - j - 1, i - j)))
                givens_rotate(unitary,
                              gmat.conj(),
                              i - j - 1,
                              i - j,
                              which='col')
        else:
            for j in range(1, i + 1):
                # elimination of U[N + j - i, j] by mixing U[N + j - i, j] and
                # U[N + j - i - 1, j] by left multiplication
                # of a givens rotation that rotates row space
                # [N + j - i - 1, N + j - i
                gmat = givens_matrix_elements(unitary[N + j - i - 1 - 1, j - 1],
                                              unitary[N + j - i - 1, j - 1],
                                              which='right')
                left_rotations.append((gmat, (N + j - i - 2, N + j - i - 1)))
                givens_rotate(unitary,
                              gmat,
                              N + j - i - 2,
                              N + j - i - 1,
                              which='row')

    new_left_rotations = []
    for (left_gmat, (i, j)) in reversed(left_rotations):
        phase_matrix = numpy.diag([unitary[i, i], unitary[j, j]])
        matrix_to_decompose = left_gmat.conj().T.dot(phase_matrix)
        new_givens_matrix = givens_matrix_elements(matrix_to_decompose[1, 0],
                                                   matrix_to_decompose[1, 1],
                                                   which='left')
        new_phase_matrix = matrix_to_decompose.dot(new_givens_matrix.T)

        # check if T_{m,n}^{-1}D  = D T.
        # coverage: ignore
        if not numpy.allclose(new_phase_matrix.dot(new_givens_matrix.conj()),
                              matrix_to_decompose):
            raise GivensTranspositionError("Failed to shift the phase matrix "
                                           "from right to left")
        # coverage: ignore

        unitary[i, i], unitary[j, j] = new_phase_matrix[0, 0], new_phase_matrix[
            1, 1]
        new_left_rotations.append((new_givens_matrix.conj(), (i, j)))

    phases = numpy.diag(unitary)
    rotations = []
    ordered_rotations = []
    for (gmat, (i, j)) in list(reversed(new_left_rotations)) + list(
            map(lambda x: (x[0].conj().T, x[1]), reversed(right_rotations))):
        ordered_rotations.append((gmat, (i, j)))

        # if this throws the impossible has happened
        # coverage: ignore
        if not numpy.isclose(gmat[0, 0].imag, 0.0):
            raise GivensMatrixError(
                "Givens matrix does not obey our convention that all elements "
                "in the first column are real")
        if not numpy.isclose(gmat[1, 0].imag, 0.0):
            raise GivensMatrixError(
                "Givens matrix does not obey our convention that all elements "
                "in the first column are real")
        # coverage: ignore

        theta = numpy.arcsin(numpy.real(gmat[1, 0]))
        phi = numpy.angle(gmat[1, 1])
        rotations.append((i, j, theta, phi))

    for op in reversed(rotations):
        i, j, theta, phi = cast(Tuple[int, int, float, float], op)
        if not numpy.isclose(phi, 0.0):
            yield cirq.Z(qubits[j])**(phi / numpy.pi)

        # yield Ryxxy(-theta).on(qubits[i], qubits[j])
        yield Ryxxy(qubits[i], qubits[j], -theta)

    for idx, phase in enumerate(phases):
        if not numpy.isclose(numpy.angle(phase), 0):
            yield cirq.Z(qubits[idx])**(numpy.angle(phase) / numpy.pi)


# def Ryxxy(rads: float) -> cirq.PhasedISwapPowGate:
#     """Returns a gate with the matrix exp(-i rads (Y⊗X - X⊗Y) / 2)."""
#     return cirq.PhasedISwapPowGate(exponent=2 * rads / numpy.pi)

def Ryxxy(a, b, theta):
    """Implements the givens rotation with sqrt(iswap).
    The inverse(sqrt(iswap)) is made with z before and after"""
    yield cirq.ISWAP.on(a, b)**0.5
    yield cirq.rz(-theta + numpy.pi).on(a)
    yield cirq.rz(theta).on(b)
    yield cirq.ISWAP.on(a, b)**0.5
    yield cirq.rz(numpy.pi).on(a)


def build_rotation_circuit(ij_list, final_phases, qubits):
    """
    Given a list of Givens rotations and final ortations implement a circuit
    that performs the Givens rotations

    :param ij_list: (Qubit_i, Qubit_j, theta, phi)
    :param final_phases: list of final Rz phases on qubits
    :param qubits: List[cirq.Qid]
    :return: cirq.Circuit
    """
    circuit = cirq.Circuit()
    for op in ij_list:
        i, j, theta, phi = cast(Tuple[int, int, float, float], op)
        if not numpy.isclose(phi, 0.0):
            circuit.append(cirq.Z(qubits[j])**(phi / numpy.pi),
                           strategy=cirq.InsertStrategy.EARLIEST)
        circuit.append(Ryxxy(-theta).on(qubits[i], qubits[j]),
                       strategy=cirq.InsertStrategy.EARLIEST)

    for idx, phase in enumerate(final_phases):
        if not numpy.isclose(numpy.angle(phase), 0):
            circuit.append(cirq.Z(qubits[idx])**(numpy.angle(phase) / numpy.pi),
                           strategy=cirq.InsertStrategy.EARLIEST)
    return circuit


def build_rotation_circuits_virtual_swaps(unitary, qubits, initial_circuit,
                                          return_unitaries=False):
    """
    Build permutation circuits for measuring 1-RDM and getting fidelity

    :param unitary: unitary to implement
    :param qubits: qubits to implement on
    :param return_unitaries: optional argument to return virtually rotated
                             unitaries
    :return: List[cirq.Circuit]
    """
    num_qubits = len(qubits)
    circuits = []
    unitaries = []
    for swap_depth in range(0, num_qubits, 2):
        fswap_pairs = util.generate_fswap_pairs(swap_depth, num_qubits)
        swap_unitaries = util.generate_fswap_unitaries(fswap_pairs, num_qubits)
        shifted_unitary = unitary.copy()
        for uu in swap_unitaries:
            shifted_unitary = uu @ shifted_unitary
        unitaries.append(shifted_unitary)

        permuted_circuit = cirq.Circuit()
        permuted_circuit += initial_circuit.copy()
        permuted_circuit += optimal_givens_decomposition(qubits,
                                                         shifted_unitary.copy())
        circuits.append(permuted_circuit)

    if return_unitaries:
        return circuits, unitaries

    return circuits


def xxyy_basis_rotation(pairs):
    """Generate the measurement circuits."""
    all_ops = []
    for a, b in pairs:
        all_ops += [
            cirq.rz(-numpy.pi * 0.25).on(a),
            cirq.rz(numpy.pi * 0.25).on(b),
            cirq.ISWAP.on(a, b)**0.5
        ]
    return all_ops


def circuits_with_measurements(qubits, circuits):
    """Append the appropriate measurements to each of the permutation circuits.
    """
    num_qubits = len(qubits)
    even_pairs = [
        qubits[idx:idx + 2] for idx in numpy.arange(0, num_qubits - 1, 2)
    ]
    odd_pairs = [qubits[idx:idx + 2] for idx in
                 numpy.arange(1, num_qubits - 1, 2)]
    measure_labels = ['z', 'xy_even', 'xy_odd']
    all_circuits_with_measurements = {label: {} for label in measure_labels}
    for circuit_index in range(len(circuits)):
        for _, label in enumerate(measure_labels):
            circuit = copy.deepcopy(circuits[circuit_index])
            if label == 'xy_even':
                circuit.append(xxyy_basis_rotation(even_pairs),
                               strategy=cirq.InsertStrategy.EARLIEST)
            if label == 'xy_odd':
                circuit.append(xxyy_basis_rotation(odd_pairs),
                               strategy=cirq.InsertStrategy.EARLIEST)
            circuit.append(cirq.Moment([cirq.measure(q) for q in qubits]))
            all_circuits_with_measurements[label][circuit_index] = circuit
    return all_circuits_with_measurements


def align_givens_circuit(circuit: cirq.Circuit, physical_Z=False) -> cirq.Circuit:
    """Re-aligns the Z gates of a circuit generated by givens rotation."""
    from cirq.optimizers.stratify import stratify_circuit
    from cirq.optimizers.merge_single_qubit_gates import merge_single_qubit_gates_into_phxz
    from cirq.optimizers.synchronize_terminal_measurements import SynchronizeTerminalMeasurements
    from cirq.optimizers.drop_empty_moments import DropEmptyMoments

    merge_single_qubit_gates_into_phxz(circuit)
    circuit = stratify_circuit([lambda op: len(op.qubits) == 2,
                                lambda op: len(op.qubits) == 1], circuit)
    DropEmptyMoments().optimize_circuit(circuit)
    SynchronizeTerminalMeasurements().optimize_circuit(circuit)

    # convert PhXZ gates to virtual-Z gates
    new_moments = []
    for mm in circuit:
        current_moment = []
        for gg in mm:
            if isinstance(gg.gate, cirq.PhasedXZGate):
                if numpy.isclose(gg.gate._x_exponent, 0):
                    if physical_Z:
                        current_moment.append(cirq.ZPowGate(exponent=gg.gate._z_exponent).on(gg.qubits[0]).with_tags(cirq.google.PhysicalZTag))
                    else:
                        current_moment.append(cirq.ZPowGate(exponent=gg.gate._z_exponent).on(gg.qubits[0]))
                else:
                    current_moment.append(gg)
            else:
                # print(gg.gate)
                current_moment.append(gg)
        new_moments.append(cirq.Moment(current_moment))
    circuit = cirq.Circuit(new_moments)
    # print(circuit.to_text_diagram(transpose=True))
    return circuit

